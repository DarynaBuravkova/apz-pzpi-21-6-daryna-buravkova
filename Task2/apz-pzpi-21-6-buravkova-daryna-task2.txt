1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Для організації коду у проекті було враховано кілька архітектурних принципів для забезпечення чистоти коду та розширюваності. Програмний код в проекті розподілений на різні компоненти, використовуючи  простори імен для групування логічно пов'язаних класів. Також використовуються зовнішні бібліотеки та фреймворки, такі як Entity Framework Core, AutoMapper, і ASP.NET Core Identity, для спрощення розробки та використання готового функціоналу. Структуру програмної системи наведено на діаграмі пакетів на рисунку 1.
Користувач взаємодіє з сервером, викликаючи методи контролерів, які групують логічно пов'язані операції. Код контролеру наведено у додатку А. Контролери використовуються для обробки HTTP-запитів, в той час як сервіси містять бізнес-логіку. Це дозволяє дотримуватися принципу однієї відповідальності та полегшує тестування.
Організація включає в себе використання репозиторіїв для взаємодії з базою даних (приклад репозиторію наведено у додатку Б), використання конфігураційних файлів для зберігання налаштувань, а також використання Middleware для обробки різних етапів обробки HTTP-запитів. 

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Система охоплює кілька компонентів, а їх структура та розташування компонентів відображені на діаграмі розгортання на рисунку 2.
Web-клієнт відправляє HTTP-запити до Web API сервера для отримання та оновлення даних. Отримує відповіді у форматі JSON від Web API сервера. Мобільний додаток використовує HTTP-запити для взаємодії з Web API сервером. IoT-пристрої відправляють дані про стан кавового автомата (наприклад, рівень кави, стан автомата) до сервера та отримують команди від сервера для оновлення налаштувань або інших дій.
Web API сервер обробляє запити від веб-клієнта, мобільного додатка та IoT-пристроїв. Виконує операції з базою даних через SQL Server, який зберігає всі дані проекту, включаючи інформацію про користувачів, кавові автомати, відгуки та замовлення. 
Діаграма розгортання дозволяє легко зрозуміти, як система фізично організована та які компоненти взаємодіють між собою. Це важливий інструмент для архітекторів систем та розробників для планування та оптимізації інфраструктури системи.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Серверну частину програмної системи було розроблено у середовищі Microsoft Visual Studio 2022 на платформі .NET 6.0. Програмний код було написано на мові програмування C#.
Для створення легкого та ефективного веб-інтерфейсу використовується ASP.NET Core Web API, який обслуговує запити від клієнтів. Web API дозволяє створювати RESTful служби, що зробило його ідеальним вибором для взаємодії між клієнтом і сервером в створюваній програмній системі.
Entity Framework Core використовується для роботи з базою даних, забезпечуючи об'єктно-реляційне відображення (ORM). В даному випадку, було обрано Microsoft SQL Server як реляційну базу даних. EF Core спростив взаємодію з базою даних, дозволивши працювати з об'єктами .NET.
 Система авторизації та управління користувачами реалізована за допомогою ASP.NET Core Identity. Це забезпечило базову імплементацію, таку як реєстрація користувачів, автентифікація, видалення та рольовий доступ. Використовується JWT для безпечного обміну інформацією про аутентифікацію між клієнтом і сервером. Він використовується як механізм передачі токена після успішної аутентифікації, щоб дозволити клієнту отримати доступ до обмежених ресурсів. Алгоритм генерації JWT наведено у додатку В.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ
  
Проектована програмна система охоплює три основні ролі користувачів: адміністратор, технічний спеціаліст та клієнт. Інформаційні потреби цих груп користувачів представлені на детальній Use-case діаграмі (див. рис. 3). На ній відображено усі можливі дії користувачів.
Крім основних потреб, усі користувачі інформаційної системи повинні мати інструменти пошуку та фільтрації:
адміністратор, що потребує детальної інформації про автомати та замовлення → потреба в можливості пошуку автоматів за назвою автомату або фільтрації за місцезнаходженням, а замовлення за його номером;
адміністратор, що потребує детальної інформації про напої → потреба в можливості пошуку напоїв за назвою або типом напою;
технічний працівник, що потребує детальної інформації про власні автомати → потреба в можливості фільтрації автомобілів, які працюють (або не працюють);
клієнти, що потребують детальної інформації про автомати, які працюють → потреба в можливості фільтрацій автоматів за місцезнаходженням
клієнти, що потребують детальної інформації про напої, які можна замовити → потреба в можливості пошуку напоїв за назвою.

5 ПОБУДОВА ER-ДІАГРАМИ

ER-діаграма є однієї із ключових концепцій, що застосовуються в процесі розробки баз даних. За допомогою цієї діаграми структуру даних було ретельно спроектовано, перш ніж модель була реалізована у вигляді бази даних. У розроблювальному проекті діаграма визначає взаємини між користувачами, автоматами, їх статусами та параметрами, напоями, їх відгуками, регіонами та замовленнями. На рисунку 4 представлено інфологічну модель бази даних, на якій відображено всі сутності бази даних, відношення між ними та атрибути.
На даній діаграмі можно побачити зв'язки типу «один-до-багатьох» між сутностями: «Користувач» і «Замовлення», оскільки кожен клієнт може робити багато замовлень, але кожне замовлення належить лише одній певній людині; «Відгук» і «Кава», тому що кожен відгук може бути написаний лише одному напою, а один напій може мати декілька відгуків; «Автомат» і «Регіон», адже кожен автомат стоїть тільки в одному місті в певний час, а в одному й тому самому місті може знаходитися декілька автоматів; «Кава» і «Замовлення», так, як кожен напій може бути замовлений не один раз за весь період, а кожному замовленню належить лише один напій; «Замовлення» і «Автомат», оскільки кожне замовлення має конкретний автомат, в якому було зроблено замовлення, а в одному й тому самому автоматі може бути зроблено декілька замовлень, «Автомат» і «Технічний спеціаліст», тому що кожен автомат може обслуговувати лише один спеціаліст, а один спеціаліст може обслуговувати декілька автоматів.
Було змодельовано зв'язок типу «багато-до-багатьох» між таблицями «Кава» та «Автомат» через таблицю «Кава-Автомат», оскільки один автомат може мати багато напоїв для приготування, та один і той самий напій може готуватися у багатьох автоматах.
Також було створено ще зв'язки типу «один-до-одного» між сутностями: «Автомат» і «Статус автомата» та «Автомат» і «Параметри автомата», тому що кожному автомату відповідає лише один статус машини та одні параметри приготування, і навпаки.

6 СПЕЦИФІКАЦІЯ REST

Система взаємодії із серверною частиною розроблена відповідно до архітектурного стилю REST (Representational State Transfer). У даній системі REST API визначає низку кінцевих точок, які дозволяють клієнтам взаємодіяти з сервером. Кожна кінцева точка відповідає певному функціоналу чи операції. Усі деталі та описи доступних операцій REST API подано в таблиці 1.

Таблиця 1 – Специфікація REST 
Метод   Деталі  Опис
POST   /api/Admin/BackupDatabase    Створити бекап бази даних
GET    /api/Admin/LastBackupDate    Отримати дату останнього бекапу
POST   /api/Admin/RestoreDatabase    Відновити базу даних
POST   /api/Auth/Login    Авторизація користувача
POST   /api/Auth/Register    Реєстрація користувача
POST   /api/Auth/RegisterTechnician    Реєстрація технічного спеціаліста
POST   /api/Auth/RegisterAdmin    Реєстрація адміна
GET    /api/Coffee    Отримати список напоїв
POST   /api/Coffee    Створити напій
GET    /api/Coffee/id    Отримати напій за id
PUT    /api/Coffee/id    Змінити дані напою за id
DELETE /api/Coffee/id    Видалити напій
GET    /api/CoffeeMachine    Отримати напої для автоматів
GET    /api/Coffee/CofeeMachine/id    Отримати напої для конкретного автомату за id
GET    /api/Machine    Отримати автомати
POST   /api/Machine    Створити автомат
GET    /api/Machine/id    Отримати автомат за id
PUT    /api/Machine/id    Змінити дані про конкретний автомат
DELETE /api/Machine/id    Видалити автомат
GET    /api/Machine/isWorking    Отримати доступні автомати
GET    /api/Machine/Region/id    Отримати автомати за певним регіоном
GET    /api/Machine/Coffee/id    Отримати автомати з конкретним напоєм
POST   /api/Machine/Coffee    Додати напій до автомата
GET    /api/MachineParametr/id    Отримати параметр конкретного автомату
PUT    /api/MachineParametr/id    Змінити параметр конкретного автомату
GET    /api/MachineStatus/id    Отримати статус конкретного автомату
PUT    /api/MachineStatus/id    Змінити статус конкретного автомату
GET    /api/MachineStatus/MachineCondition/id    Отримати стан обладнання конкретного автомату
GET    /api/Order    Отримати список замовлень 
POST   /api/Order    Створити замовлення
GET    /api/Order/id    Отримати конкретне замовлення
GET    /api/Order/User/id    Отримати список замовлень користувача
GET    /api/Region    Отримати всі регіони
POST   /api/Region    Створити регіон
GET    /api/Region/id    Отримати регіон за id
PUT    /api/Region/id    Змінити дані регіону
DELETE /api/Region/id    Видалити регіон
POST   /api/Review/Coffee/Id    Створити відгук для напою
GET    /api/Review/Coffee/Id    Отримати відгуки для напою
GET    /api/Review/AverageRating/id    Отримати середню оцінку напою
GET    /api/Technician    Отримати список технічних працівників
GET    /api/Technician/id    Отримати конкретного технічного працівника
PUT    /api/Technician/id    Змінити дані працівника
DELETE /api/Technician/id    Видалити працівника
GET    /api/User    Отримати список всіх користувачів
PUT    /api/User/id    Змінити дані конкретного користувача
GET    /api/User/id    Отримати дані конкретного користувача
DELETE /api/User/id    Видалити користувача

ВИСНОВКИ

В ході виконання лабораторної роботи було спроектовано та розроблено серверну частину програмної системи, прийнято ряд інженерних рішень, спрямованих на досягнення високої якості та ефективності розробленого продукту.
Однією з ключових архітектурних виборів був вибір стилю REST для взаємодії з серверною частиною. Проектування REST API було детально зроблено, і вся необхідна інформація щодо доступних операцій була визначена.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

Посилання на відеоролик з тестуванням серверної частини:
Посилання на архів з кодом серверної частини: 

